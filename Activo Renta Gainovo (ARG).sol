/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXXXXXXNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNX0kdlc;,'.........',:coxOKNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0xl:'.                        .':oOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:'.                                  .:d0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOl,.                                         .;xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMW0o'                                                ,OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMNO:.                                                 .oXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMNO;.                                                  .kWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMW0c.                         ..........                ;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMNd.                    .':ldk0KXXNNNNXKKOxoc,.        .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMK:                   .cx0NWMMMMMMMMMMMMMMMMMMWKkl'    .xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMWO,                 .:kXWMMMMMMMMMMMMMMMMMMMMMMMMMMNOc.;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMWk.                .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMWO'                'kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMM0,                :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMXc                cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMWx.               ;KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMK;               .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMx.               cNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMNc               .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMK,               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOkXMMMMMMMMMMMMMMMM
MMMMMMMMMMMO.               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0koc,.  :XMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               .OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOxl;'.       .oWMMMMMMMMMMMMMM
MMMMMMMMMMMK,               .dWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKkoc,.              .kMMMMMMMMMMMMMM
MMMMMMMMMMMX:                :XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX0xl:'.                    ;KMMMMMMMMMMMMM
MMMMMMMMMMMWd                .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkdc,.                           lNMMMMMMMMMMMM
MMMMMMMMMMMM0'                ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.                               .dWMMMMMMMMMMM
MMMMMMMMMMMMNl                 cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:                                'OMMMMMMMMMMM
MMMMMMMMMMMMM0,                .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0'                                :XMMMMMMMMMM
MMMMMMMMMMMMMWx.                .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.          ...                   oNMMMMMMMMM
MMMMMMMMMMMMMMNo                  :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNl     .,cokOo.                   .kWMMMMMMMM
MMMMMMMMMMMMMMMXc                  'xNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKl;ldOXWMMKl.                     ,0MMMMMMMM
MMMMMMMMMMMMMMMMXc                  .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWMMMMMNx'                        cXMMMMMMM
MMMMMMMMMMMMMMMMMXl                   .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXx,              .           .dWMMMMMM
MMMMMMMMMMMMMMMMMMNd.                    ,o0NMMMMMMMMMMMMMMMMMMMMMMMMMNOl'              .od.           .OMMMMMM
MMMMMMMMMMMMMMMMMMMWO,                     .,lx0NWMMMMMMMMMMMMMMMWNKxl'.               .dNNl          .;kWMMMMM
MMMMMMMMMMMMMMMMMMMMMXo.                       ..;coxkO000K00Oxdl;'.                  .kWMMK:   .':lx0XWMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMW0:.                               ...                         ;0WMMMM0ookKNWMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMWO:.                                                       .dNMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMNOc.                                                   .lKWMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.                                              'l0WMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0o;.                                        .:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc,.                                .'cxKWMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKkoc,..                    ..':okKNMMMMMMMMMMM   WWW.GAINOVO.COM    MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXKOxdlcc:;;;;;;::clodk0XNMMMMMMMMMMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
/////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// ---------------
// Librería ECDSA 
// ---------------

library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS
    }

    /**
     * @dev The signature derives the `address(0)`.
     */
    error ECDSAInvalidSignature();

    /**
     * @dev The signature has an invalid length.
     */
    error ECDSAInvalidSignatureLength(uint256 length);

    /**
     * @dev The signature has an S value that is in the upper half order.
     */
    error ECDSAInvalidSignatureS(bytes32 s);

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error.
     */
    function tryRecover(
        bytes32 hash,
        bytes memory signature
    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover toma los parámetros de la firma; la única forma de obtenerlos es usando assembly.
            assembly ("memory-safe") {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with `signature`.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     */
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
        unchecked {
            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
            // El shift genera 0 o 1.
            uint8 v = uint8((uint256(vs) >> 255) + 27);
            return tryRecover(hash, v, r, s);
        }
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.
     */
    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {
        // Se evita la posibilidad de signatures malleables, forzando s a estar en el rango inferior.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS, s);
        }

        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature, bytes32(0));
        }

        return (signer, RecoverError.NoError, bytes32(0));
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Reverts con el error correspondiente si `error` no es NoError.
     */
    function _throwError(RecoverError error, bytes32 errorArg) private pure {
        if (error == RecoverError.NoError) {
            return; // sin error: continúa
        } else if (error == RecoverError.InvalidSignature) {
            revert ECDSAInvalidSignature();
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert ECDSAInvalidSignatureLength(uint256(errorArg));
        } else if (error == RecoverError.InvalidSignatureS) {
            revert ECDSAInvalidSignatureS(errorArg);
        }
    }
}

// =====================================================================
// Interfaz IERC20 estándar
// =====================================================================
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// =====================================================================
// Interfaz IERC20Permit para EIP-2612
// =====================================================================
interface IERC20Permit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// =====================================================================
// Contrato Activo Renta Gainovo
// =====================================================================
/**
 * @title Activo Renta Gainovo
 * @notice Token ERC20 con sistema multi‑firma, listas blanca/negra, pausabilidad por rol de emergencia y EIP‑2612.
 */
contract ActivoRentaGainovo is IERC20, IERC20Permit {
    using ECDSA for bytes32;

    // -----------------------
    // Datos básicos del token
    // -----------------------
    string public constant name = "Activo Renta Gainovo";
    string public constant symbol = "ARG";
    uint8 public constant decimals = 18;
    uint256 private _totalSupply;
    
    // -----------------------
    // Mapeos ERC20
    // -----------------------
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    // -----------------------
    // Gestión de propietarios (multi‑firma)
    // -----------------------
    mapping(address => bool) public esPropietario;
    address[] public propietarios;
    // Mapeo para optimizar la remoción de propietarios
    mapping(address => uint256) private ownerIndex;
    uint256 public conteoPropietarios;
    
    /**
     * @dev Modifier que permite solo a propietarios ejecutar la función.
     */
    modifier soloPropietario() {
        require(esPropietario[msg.sender], "Solo propietarios");
        _;
    }
    
    // -----------------------
    // Gestión de gestores
    // -----------------------
    mapping(address => bool) public gestores;
    modifier soloGestor() {
        require(gestores[msg.sender], "Solo gestores");
        _;
    }
    
    // -----------------------
    // Gestión de rol de emergencia
    // -----------------------
    mapping(address => bool) public emergencia;
    modifier soloEmergencia() {
        require(emergencia[msg.sender], "Solo rol de emergencia");
        _;
    }
    
    // -----------------------
    // Gestión de pausabilidad
    // -----------------------
    bool public paused;
    modifier whenNotPaused() {
        require(!paused, "Token pausado");
        _;
    }
    
    // -----------------------
    // Sistema de propuestas multi‑firma
    // -----------------------
    uint256 public conteoPropuestas;
    uint256 constant expiracionPropuesta = 24 hours;
    
    /**
     * @dev Tipo de operaciones permitidas mediante propuestas.
     */
    enum TipoOperacion { 
        Mintear, 
        Quemar, 
        AlternarListaBlanca, 
        AlternarListaNegra, 
        AgregarGestor, 
        RemoverGestor, 
        AgregarPropietario, 
        RemoverPropietario,
        AgregarEmergencia,
        RemoverEmergencia,
        PausarToken,
        ReanudarToken
    }
    
    /**
     * @dev Estructura de una propuesta multi‑firma.
     */
    struct Propuesta {
        TipoOperacion tipoOperacion;
        address destino;
        uint256 cantidad;
        bool nuevoEstado; // usado en operaciones de alternar listas
        uint256 timestamp;
        uint256 aprobaciones;
        bool ejecutada;
        bool cancelada;
    }
    
    // Almacenamiento de propuestas y aprobaciones
    mapping(uint256 => Propuesta) public propuestas;
    mapping(uint256 => mapping(address => bool)) public aprobacionesPropuestas;
    
    // -----------------------
    // Gestión de listas (blanca y negra)
    // -----------------------
    bool public listaBlancaActiva;
    bool public listaNegraActiva;
    mapping(address => bool) public listaBlanca;
    mapping(address => bool) public listaNegra;
    
    // -----------------------
    // EIP‑2612 (permit)
    // -----------------------
    bytes32 public immutable DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = 
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;
    
    // -----------------------
    // Eventos
    // -----------------------
    event PropuestaCreada(uint256 indexed id, TipoOperacion tipo, address destino, uint256 cantidad, bool nuevoEstado, uint256 timestamp);
    event PropuestaConfirmada(uint256 indexed id, address propietario, uint256 aprobaciones);
    event PropuestaEjecutada(uint256 indexed id, TipoOperacion tipo);
    event PropuestaCancelada(uint256 indexed id);
    event Paused(address account);
    event Unpaused(address account);
    
    // -----------------------
    // Constructor
    // -----------------------
    /**
     * @notice Inicializa el token con una lista inicial de propietarios y configura EIP‑712.
     * @param propietariosIniciales Arreglo con direcciones de propietarios (mínimo 3).
     */
    constructor(address[] memory propietariosIniciales) {
        require(propietariosIniciales.length >= 3, "Se requieren al menos 3 propietarios");
        for (uint i = 0; i < propietariosIniciales.length; i++) {
            address propietarioAddr = propietariosIniciales[i];
            require(propietarioAddr != address(0), "Propietario invalido");
            if (!esPropietario[propietarioAddr]) {
                esPropietario[propietarioAddr] = true;
                ownerIndex[propietarioAddr] = propietarios.length;
                propietarios.push(propietarioAddr);
            }
        }
        conteoPropietarios = propietarios.length;
        
        // Inicialmente se mintea solo 1 token (1 * 10^18 unidades) al primer propietario
        _totalSupply = 1 * (10 ** decimals);
        _balances[propietarios[0]] = _totalSupply;
        emit Transfer(address(0), propietarios[0], _totalSupply);
        
        // Configuración EIP‑712
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(name)),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }
    
    // -----------------------
    // Funciones ERC20 (compatibilidad)
    // -----------------------
    function totalSupply() external view override(IERC20) returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view override(IERC20) returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address recipient, uint256 amount) external override(IERC20) whenNotPaused returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external override(IERC20) whenNotPaused returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    
    function allowance(address owner, address spender) external view override(IERC20) returns (uint256) {
        return _allowances[owner][spender];
    }
    
    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) whenNotPaused returns (bool) {
        _spendAllowance(sender, msg.sender, amount);
        _transfer(sender, recipient, amount);
        return true;
    }
    
    // -----------------------
    // EIP‑2612: permit
    // -----------------------
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override(IERC20Permit) {
        require(block.timestamp <= deadline, "Permiso expirado");
        
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                value,
                nonces[owner],
                deadline
            )
        );
        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash)
        );
        address recoveredAddress = digest.recover(v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, "Firma invalida");
        
        nonces[owner]++;
        _approve(owner, spender, value);
    }
    
    // -----------------------
    // Funciones internas ERC20
    // -----------------------
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0) && recipient != address(0), "Direccion invalida");
        
        if (listaBlancaActiva) {
            require(listaBlanca[sender] && listaBlanca[recipient], "Direccion no en lista blanca");
        }
        if (listaNegraActiva) {
            require(!listaNegra[sender] && !listaNegra[recipient], "Direccion en lista negra");
        }
        
        uint256 saldoRemitente = _balances[sender];
        require(saldoRemitente >= amount, "Saldo insuficiente");
        unchecked {
            _balances[sender] = saldoRemitente - amount;
            _balances[recipient] += amount;
        }
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(spender != address(0), "Direccion invalida");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    function _spendAllowance(address owner, address spender, uint256 amount) internal {
        uint256 currentAllowance = _allowances[owner][spender];
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "Allowance excedido");
            unchecked {
                _allowances[owner][spender] = currentAllowance - amount;
            }
        }
    }
    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "No se puede mintear a 0");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "No se puede quemar de 0");
        require(_balances[account] >= amount, "Cantidad a quemar mayor al saldo");
        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }
    
    // -----------------------
    // Funciones de propuestas multi‑firma
    // -----------------------
    /**
     * @notice Crea una propuesta para una operación sensible.
     * @param tipo Tipo de operación a ejecutar.
     * @param destino Dirección destino (puede ser 0 para algunas operaciones).
     * @param cantidad Monto involucrado (para minteo/quemado).
     * @param nuevoEstado Nuevo estado para operaciones que lo requieran (listas).
     * @return idPropuesta Identificador de la propuesta creada.
     */
    function _crearPropuesta(
        TipoOperacion tipo,
        address destino,
        uint256 cantidad,
        bool nuevoEstado
    ) internal returns (uint256 idPropuesta) {
        require(destino != address(0) || (tipo != TipoOperacion.Mintear && tipo != TipoOperacion.Quemar && tipo != TipoOperacion.AgregarGestor && tipo != TipoOperacion.RemoverGestor && tipo != TipoOperacion.AgregarPropietario && tipo != TipoOperacion.RemoverPropietario && tipo != TipoOperacion.AgregarEmergencia && tipo != TipoOperacion.RemoverEmergencia), "Direccion invalida");
        conteoPropuestas++;
        idPropuesta = conteoPropuestas;
        propuestas[idPropuesta] = Propuesta({
            tipoOperacion: tipo,
            destino: destino,
            cantidad: cantidad,
            nuevoEstado: nuevoEstado,
            timestamp: block.timestamp,
            aprobaciones: 1, // se cuenta la aprobación del creador
            ejecutada: false,
            cancelada: false
        });
        aprobacionesPropuestas[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, tipo, destino, cantidad, nuevoEstado, block.timestamp);
    }
    
    // Funciones públicas para crear propuestas según operación:
    function proponerMintear(address destino, uint256 cantidad) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.Mintear, destino, cantidad, false);
    }
    
    function proponerQuemar(address destino, uint256 cantidad) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.Quemar, destino, cantidad, false);
    }
    
    function proponerAlternarListaBlanca(bool nuevoEstado) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.AlternarListaBlanca, address(0), 0, nuevoEstado);
    }
    
    function proponerAlternarListaNegra(bool nuevoEstado) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.AlternarListaNegra, address(0), 0, nuevoEstado);
    }
    
    function proponerAgregarGestor(address gestor) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.AgregarGestor, gestor, 0, false);
    }
    
    function proponerRemoverGestor(address gestor) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.RemoverGestor, gestor, 0, false);
    }
    
    function proponerAgregarPropietario(address nuevoPropietario) external soloPropietario returns (uint256) {
        require(!esPropietario[nuevoPropietario], "Ya es propietario");
        return _crearPropuesta(TipoOperacion.AgregarPropietario, nuevoPropietario, 0, false);
    }
    
    function proponerRemoverPropietario(address propietarioAddr) external soloPropietario returns (uint256) {
        require(esPropietario[propietarioAddr], "No es propietario");
        require(conteoPropietarios > 3, "No se puede tener menos de 3 propietarios");
        return _crearPropuesta(TipoOperacion.RemoverPropietario, propietarioAddr, 0, false);
    }
    
    function proponerAgregarEmergencia(address cuenta) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.AgregarEmergencia, cuenta, 0, false);
    }
    
    function proponerRemoverEmergencia(address cuenta) external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.RemoverEmergencia, cuenta, 0, false);
    }
    
    function proponerPausarToken() external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.PausarToken, address(0), 0, false);
    }
    
    function proponerReanudarToken() external soloPropietario returns (uint256) {
        return _crearPropuesta(TipoOperacion.ReanudarToken, address(0), 0, false);
    }
    
    /**
     * @notice Registra la confirmación de una propuesta pendiente.
     * @param idPropuesta Identificador de la propuesta.
     */
    function confirmarPropuesta(uint256 idPropuesta) external soloPropietario {
        require(idPropuesta > 0 && idPropuesta <= conteoPropuestas, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[idPropuesta];
        require(!propuesta.ejecutada, "Propuesta ya ejecutada");
        require(!propuesta.cancelada, "Propuesta cancelada");
        require(block.timestamp <= propuesta.timestamp + expiracionPropuesta, "Propuesta expirada");
        require(!aprobacionesPropuestas[idPropuesta][msg.sender], "Ya aprobaste");
        
        aprobacionesPropuestas[idPropuesta][msg.sender] = true;
        propuesta.aprobaciones++;
        emit PropuestaConfirmada(idPropuesta, msg.sender, propuesta.aprobaciones);
    }
    
    /**
     * @notice Ejecuta una propuesta pendiente que ya cuenta con las aprobaciones requeridas.
     * @param idPropuesta Identificador de la propuesta.
     */
    function ejecutarPropuesta(uint256 idPropuesta) external soloPropietario {
        require(idPropuesta > 0 && idPropuesta <= conteoPropuestas, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[idPropuesta];
        require(!propuesta.ejecutada, "Propuesta ya ejecutada");
        require(!propuesta.cancelada, "Propuesta cancelada");
        require(block.timestamp <= propuesta.timestamp + expiracionPropuesta, "Propuesta expirada");
        require(_suficientesAprobaciones(idPropuesta), "Aprobaciones insuficientes");
        _ejecutarPropuesta(idPropuesta);
    }
    
    /**
     * @notice Cancela una propuesta que haya expirado.
     * @param idPropuesta Identificador de la propuesta.
     */
    function cancelarPropuestaExpirada(uint256 idPropuesta) external soloPropietario {
        require(idPropuesta > 0 && idPropuesta <= conteoPropuestas, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[idPropuesta];
        require(!propuesta.ejecutada, "Ya ejecutada");
        require(!propuesta.cancelada, "Ya cancelada");
        require(block.timestamp > propuesta.timestamp + expiracionPropuesta, "Propuesta aun activa");
        propuesta.cancelada = true;
        emit PropuestaCancelada(idPropuesta);
    }
    
    /**
     * @dev Verifica si una propuesta alcanza el umbral requerido.
     * Se utiliza el 2/3 de los propietarios.
     */
    function _suficientesAprobaciones(uint256 idPropuesta) internal view returns (bool) {
        // Umbral para alcanzar aprobación
        uint256 umbral = (2 * conteoPropietarios + 1) / 3;
        return propuestas[idPropuesta].aprobaciones >= umbral;
    }
    
    /**
     * @dev Ejecuta la propuesta aprobada.
     */
    function _ejecutarPropuesta(uint256 idPropuesta) internal {
        Propuesta storage propuesta = propuestas[idPropuesta];
        require(!propuesta.ejecutada, "Ya ejecutada");
        require(!propuesta.cancelada, "Propuesta cancelada");
        
        if (propuesta.tipoOperacion == TipoOperacion.Mintear) {
            _mint(propuesta.destino, propuesta.cantidad);
        } else if (propuesta.tipoOperacion == TipoOperacion.Quemar) {
            _burn(propuesta.destino, propuesta.cantidad);
        } else if (propuesta.tipoOperacion == TipoOperacion.AlternarListaBlanca) {
            listaBlancaActiva = propuesta.nuevoEstado;
        } else if (propuesta.tipoOperacion == TipoOperacion.AlternarListaNegra) {
            listaNegraActiva = propuesta.nuevoEstado;
        } else if (propuesta.tipoOperacion == TipoOperacion.AgregarGestor) {
            gestores[propuesta.destino] = true;
        } else if (propuesta.tipoOperacion == TipoOperacion.RemoverGestor) {
            gestores[propuesta.destino] = false;
        } else if (propuesta.tipoOperacion == TipoOperacion.AgregarPropietario) {
            require(!esPropietario[propuesta.destino], "Ya es propietario");
            esPropietario[propuesta.destino] = true;
            ownerIndex[propuesta.destino] = propietarios.length;
            propietarios.push(propuesta.destino);
            conteoPropietarios++;
        } else if (propuesta.tipoOperacion == TipoOperacion.RemoverPropietario) {
            require(conteoPropietarios > 3, "No se puede tener menos de 3 propietarios");
            esPropietario[propuesta.destino] = false;
            uint256 index = ownerIndex[propuesta.destino];
            address lastOwner = propietarios[propietarios.length - 1];
            propietarios[index] = lastOwner;
            ownerIndex[lastOwner] = index;
            propietarios.pop();
            delete ownerIndex[propuesta.destino];
            conteoPropietarios--;
        } else if (propuesta.tipoOperacion == TipoOperacion.AgregarEmergencia) {
            emergencia[propuesta.destino] = true;
        } else if (propuesta.tipoOperacion == TipoOperacion.RemoverEmergencia) {
            emergencia[propuesta.destino] = false;
        } else if (propuesta.tipoOperacion == TipoOperacion.PausarToken) {
            paused = true;
            emit Paused(msg.sender);
        } else if (propuesta.tipoOperacion == TipoOperacion.ReanudarToken) {
            paused = false;
            emit Unpaused(msg.sender);
        }
        
        propuesta.ejecutada = true;
        emit PropuestaEjecutada(idPropuesta, propuesta.tipoOperacion);
    }
    
    // -----------------------
    // Funciones de gestión de listas (solo gestores)
    // -----------------------
    function agregarAListaBlanca(address cuenta) external soloGestor {
        require(cuenta != address(0), "Direccion invalida");
        listaBlanca[cuenta] = true;
    }
    
    function removerDeListaBlanca(address cuenta) external soloGestor {
        require(cuenta != address(0), "Direccion invalida");
        listaBlanca[cuenta] = false;
    }
    
    function agregarAListaNegra(address cuenta) external soloGestor {
        require(cuenta != address(0), "Direccion invalida");
        require(!esPropietario[cuenta], "No se pueden bloquear propietarios");
        listaNegra[cuenta] = true;
    }
    
    function removerDeListaNegra(address cuenta) external soloGestor {
        require(cuenta != address(0), "Direccion invalida");
        listaNegra[cuenta] = false;
    }
    
    // -----------------------
    // Funciones de pausa/reanudación (solo rol de emergencia)
    // -----------------------
    function pause() external soloEmergencia {
        require(!paused, "Ya pausado");
        paused = true;
        emit Paused(msg.sender);
    }
    
    function unpause() external soloEmergencia {
        require(paused, "No esta pausado");
        paused = false;
        emit Unpaused(msg.sender);
    }
}