/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXXXXXXNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNX0kdlc;,'.........',:coxOKNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0xl:'.                        .':oOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:'.                                  .:d0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOl,.                                         .;xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMW0o'                                                ,OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMNO:.                                                 .oXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMNO;.                                                  .kWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMW0c.                         ..........                ;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMNd.                    .':ldk0KXXNNNNXKKOxoc,.        .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMK:                   .cx0NWMMMMMMMMMMMMMMMMMMWKkl'    .xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMWO,                 .:kXWMMMMMMMMMMMMMMMMMMMMMMMMMMNOc.;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMWk.                .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMWO'                'kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMM0,                :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMXc                cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMWx.               ;KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMK;               .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMx.               cNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMNc               .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMK,               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOkXMMMMMMMMMMMMMMMM
MMMMMMMMMMMO.               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0koc,.  :XMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               .OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOxl;'.       .oWMMMMMMMMMMMMMM
MMMMMMMMMMMK,               .dWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKkoc,.              .kMMMMMMMMMMMMMM
MMMMMMMMMMMX:                :XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX0xl:'.                    ;KMMMMMMMMMMMMM
MMMMMMMMMMMWd                .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkdc,.                           lNMMMMMMMMMMMM
MMMMMMMMMMMM0'                ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.                               .dWMMMMMMMMMMM
MMMMMMMMMMMMNl                 cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:                                'OMMMMMMMMMMM
MMMMMMMMMMMMM0,                .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0'                                :XMMMMMMMMMM
MMMMMMMMMMMMMWx.                .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.          ...                   oNMMMMMMMMM
MMMMMMMMMMMMMMNo                  :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNl     .,cokOo.                   .kWMMMMMMMM
MMMMMMMMMMMMMMMXc                  'xNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKl;ldOXWMMKl.                     ,0MMMMMMMM
MMMMMMMMMMMMMMMMXc                  .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWMMMMMNx'                        cXMMMMMMM
MMMMMMMMMMMMMMMMMXl                   .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXx,              .           .dWMMMMMM
MMMMMMMMMMMMMMMMMMNd.                    ,o0NMMMMMMMMMMMMMMMMMMMMMMMMMNOl'              .od.           .OMMMMMM
MMMMMMMMMMMMMMMMMMMWO,                     .,lx0NWMMMMMMMMMMMMMMMWNKxl'.               .dNNl          .;kWMMMMM
MMMMMMMMMMMMMMMMMMMMMXo.                       ..;coxkO000K00Oxdl;'.                  .kWMMK:   .':lx0XWMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMW0:.                               ...                         ;0WMMMM0ookKNWMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMWO:.                                                       .dNMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMNOc.                                                   .lKWMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.                                              'l0WMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0o;.                                        .:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc,.                                .'cxKWMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKkoc,..                    ..':okKNMMMMMMMMMMM   WWW.GAINOVO.COM    MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXKOxdlcc:;;;;;;::clodk0XNMMMMMMMMMMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
/////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// ================== IERC165 ==================
interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// ================== IERC20 ==================
interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

// ================== IERC1363 ==================
interface IERC1363 is IERC20, IERC165 {
    function transferAndCall(address to, uint256 value) external returns (bool);
    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);
    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);
    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);
    function approveAndCall(address spender, uint256 value) external returns (bool);
    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);
}

// ================== SafeERC20 ==================
library SafeERC20 {
    error SafeERC20FailedOperation(address token);
    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        forceApprove(token, spender, oldAllowance + value);
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
        unchecked {
            uint256 currentAllowance = token.allowance(address(this), spender);
            if (currentAllowance < requestedDecrease) {
                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
            }
            forceApprove(token, spender, currentAllowance - requestedDecrease);
        }
    }

    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
            _callOptionalReturn(token, approvalCall);
        }
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        uint256 returnSize;
        uint256 returnValue;
        assembly {
            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
            if iszero(success) {
                let ptr := mload(0x40)
                returndatacopy(ptr, 0, returndatasize())
                revert(ptr, returndatasize())
            }
            returnSize := returndatasize()
            returnValue := mload(0)
        }
        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {
            revert SafeERC20FailedOperation(address(token));
        }
    }

    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        bool success;
        uint256 returnSize;
        uint256 returnValue;
        assembly {
            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
            returnSize := returndatasize()
            returnValue := mload(0)
        }
        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);
    }
}

// ================== ReentrancyGuard ==================
abstract contract ReentrancyGuard {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;

    uint256 private _status;

    error ReentrancyGuardReentrantCall();

    constructor() {
        _status = NOT_ENTERED;
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        if (_status == ENTERED) {
            revert ReentrancyGuardReentrantCall();
        }
        _status = ENTERED;
    }

    function _nonReentrantAfter() private {
        _status = NOT_ENTERED;
    }

    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == ENTERED;
    }
}

// ================== Gainovo MultiSender Contract ==================
contract MultiSenderGainovo is ReentrancyGuard {
    using SafeERC20 for IERC20;

    enum TipoPropuesta {
        CambiarPrimario,
        CambiarSecundario,
        AgregarPropietario,
        RemoverPropietario,
        RetirarPrimario,
        RetirarSecundario,
        RetirarETH
    }
    
    enum EstadoPropuesta {
        Activa,
        Aprobada,
        Ejecutada,
        Rechazada,
        Expirada
    }
    
    struct Propuesta {
        TipoPropuesta tipoPropuesta;
        address proponente;
        address direccionObjetivo;
        address direccionAdicional;
        uint256 valorNumerico;
        uint256 confirmaciones;
        uint256 rechazos;
        EstadoPropuesta estado;
        uint256 fechaCreacion;
        uint256 fechaExpiracion;
    }

    IERC20 public tokenPrimario;
    IERC20 public tokenSecundario;
    address[] public propietarios;
    mapping(address => bool) public esPropietario;
    
    Propuesta[] public propuestas;
    mapping(uint256 => mapping(address => bool)) public confirmaciones;
    
    uint256 public constant TIEMPO_EXPIRACION = 1 days;
    uint256 public numeroOperacion;
    
    event PropuestaCreada(uint256 indexed idPropuesta, TipoPropuesta tipoPropuesta);
    event VotoEmitido(uint256 indexed idPropuesta, address indexed votante, bool aFavor);
    event PropuestaAprobada(uint256 indexed idPropuesta);
    event PropuestaRechazada(uint256 indexed idPropuesta);
    event PropuestaEjecutada(uint256 indexed idPropuesta);
    event OperacionRealizada(uint256 numeroOperacion);
    event TokensPrimariosRetirados(uint256 monto, address destino);
    event TokensSecundariosRetirados(uint256 monto, address destino);
    event ETHRetirado(uint256 monto, address destino);
    
    modifier soloPropietario() {
        require(esPropietario[msg.sender], "Solo propietarios");
        _;
    }
    
    modifier noExpirada(uint256 _idPropuesta) {
        Propuesta storage propuesta = propuestas[_idPropuesta];
        require(propuesta.estado != EstadoPropuesta.Expirada, "Propuesta expirada");
        require(block.timestamp <= propuesta.fechaExpiracion, "Propuesta expirada");
        _;
    }

    constructor(
        address _tokenPrimario,
        address _tokenSecundario,
        address[] memory _propietarios
    ) {
        require(_propietarios.length == 3, "Se necesitan 3 propietarios iniciales");
        for (uint256 i = 0; i < _propietarios.length; i++) {
            address propietario = _propietarios[i];
            require(propietario != address(0), "Direccion invalida");
            require(!esPropietario[propietario], "Duplicado de propietario");
            esPropietario[propietario] = true;
            propietarios.push(propietario);
        }
        tokenPrimario = IERC20(_tokenPrimario);
        tokenSecundario = IERC20(_tokenSecundario);
    }
    
    receive() external payable {}
    
    function requiredConfirmations() public view returns (uint256) {
        uint256 n = propietarios.length;
        if (n == 3) {
            return 2;
        }
        return (n * 2 + 2) / 3;
    }
    
    // ================== Funciones de Propuestas ==================
    function proponerCambioPrimario(address _nuevoTokenPrimario) external soloPropietario {
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.CambiarPrimario,
            proponente: msg.sender,
            direccionObjetivo: _nuevoTokenPrimario,
            direccionAdicional: address(0),
            valorNumerico: 0,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.CambiarPrimario);
    }
    
    function proponerCambioSecundario(address _nuevoTokenSecundario) external soloPropietario {
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.CambiarSecundario,
            proponente: msg.sender,
            direccionObjetivo: _nuevoTokenSecundario,
            direccionAdicional: address(0),
            valorNumerico: 0,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.CambiarSecundario);
    }
    
    function proponerAgregarPropietario(address _nuevoPropietario) external soloPropietario {
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.AgregarPropietario,
            proponente: msg.sender,
            direccionObjetivo: _nuevoPropietario,
            direccionAdicional: address(0),
            valorNumerico: 0,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.AgregarPropietario);
    }
    
    function proponerRemoverPropietario(address _propietarioARemover, address _nuevoPropietario) external soloPropietario {
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.RemoverPropietario,
            proponente: msg.sender,
            direccionObjetivo: _propietarioARemover,
            direccionAdicional: _nuevoPropietario,
            valorNumerico: 0,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.RemoverPropietario);
    }
    
    function proponerRetirarPrimario(uint256 _monto, address _destino) external soloPropietario {
        require(_monto > 0, "Monto invalido");
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.RetirarPrimario,
            proponente: msg.sender,
            direccionObjetivo: _destino,
            direccionAdicional: address(0),
            valorNumerico: _monto,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.RetirarPrimario);
    }
    
    function proponerRetirarSecundario(uint256 _monto, address _destino) external soloPropietario {
        require(_monto > 0, "Monto invalido");
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.RetirarSecundario,
            proponente: msg.sender,
            direccionObjetivo: _destino,
            direccionAdicional: address(0),
            valorNumerico: _monto,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.RetirarSecundario);
    }
    
    function proponerRetirarETH(uint256 _monto, address _destino) external soloPropietario {
        require(_monto > 0, "Monto invalido");
        uint256 idPropuesta = propuestas.length;
        propuestas.push(Propuesta({
            tipoPropuesta: TipoPropuesta.RetirarETH,
            proponente: msg.sender,
            direccionObjetivo: _destino,
            direccionAdicional: address(0),
            valorNumerico: _monto,
            confirmaciones: 1,
            rechazos: 0,
            estado: EstadoPropuesta.Activa,
            fechaCreacion: block.timestamp,
            fechaExpiracion: block.timestamp + TIEMPO_EXPIRACION
        }));
        confirmaciones[idPropuesta][msg.sender] = true;
        emit PropuestaCreada(idPropuesta, TipoPropuesta.RetirarETH);
    }
    
    function votarPropuesta(uint256 _idPropuesta, bool _aFavor) external soloPropietario noExpirada(_idPropuesta) {
        require(_idPropuesta < propuestas.length, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[_idPropuesta];
        require(propuesta.estado == EstadoPropuesta.Activa, "Propuesta no activa");
        require(!confirmaciones[_idPropuesta][msg.sender], "Ya votaste esta propuesta");

        confirmaciones[_idPropuesta][msg.sender] = true;
        
        if (_aFavor) {
            propuesta.confirmaciones++;
            emit VotoEmitido(_idPropuesta, msg.sender, true);
            
            if (propuesta.confirmaciones >= requiredConfirmations()) {
                propuesta.estado = EstadoPropuesta.Aprobada;
                emit PropuestaAprobada(_idPropuesta);
            }
        } else {
            propuesta.rechazos++;
            emit VotoEmitido(_idPropuesta, msg.sender, false);
            
            if (propuesta.rechazos > (propietarios.length - requiredConfirmations())) {
                propuesta.estado = EstadoPropuesta.Rechazada;
                emit PropuestaRechazada(_idPropuesta);
            }
        }
    }

    function ejecutarPropuesta(uint256 _idPropuesta) external soloPropietario {
        require(_idPropuesta < propuestas.length, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[_idPropuesta];
        
        // Verificar expiración primero
        if (block.timestamp > propuesta.fechaExpiracion && propuesta.estado == EstadoPropuesta.Activa) {
            propuesta.estado = EstadoPropuesta.Expirada;
            emit PropuestaRechazada(_idPropuesta);
            revert("Propuesta expirada");
        }
        
        require(propuesta.estado == EstadoPropuesta.Aprobada, "Propuesta no aprobada");
        require(propuesta.estado != EstadoPropuesta.Ejecutada, "Propuesta ya ejecutada");

        _ejecutarPropuesta(_idPropuesta);
    }
    
    function _ejecutarPropuesta(uint256 _idPropuesta) internal {
        Propuesta storage propuesta = propuestas[_idPropuesta];
        propuesta.estado = EstadoPropuesta.Ejecutada;
        
        if (propuesta.tipoPropuesta == TipoPropuesta.CambiarPrimario) {
            tokenPrimario = IERC20(propuesta.direccionObjetivo);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.CambiarSecundario) {
            tokenSecundario = IERC20(propuesta.direccionObjetivo);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.AgregarPropietario) {
            _agregarPropietario(propuesta.direccionObjetivo);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.RemoverPropietario) {
            _removerPropietario(propuesta.direccionObjetivo, propuesta.direccionAdicional);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.RetirarPrimario) {
            _retirarPrimario(propuesta.valorNumerico, propuesta.direccionObjetivo);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.RetirarSecundario) {
            _retirarSecundario(propuesta.valorNumerico, propuesta.direccionObjetivo);
        } else if (propuesta.tipoPropuesta == TipoPropuesta.RetirarETH) {
            _retirarETH(propuesta.valorNumerico, propuesta.direccionObjetivo);
        }
        
        emit PropuestaEjecutada(_idPropuesta);
    }
    
    // ================== Funciones Internas de Retiro ==================
    function _retirarPrimario(uint256 _monto, address _destino) private nonReentrant {
        require(tokenPrimario.balanceOf(address(this)) >= _monto, "Saldo insuficiente");
        tokenPrimario.safeTransfer(_destino, _monto);
        emit TokensPrimariosRetirados(_monto, _destino);
    }
    
    function _retirarSecundario(uint256 _monto, address _destino) private nonReentrant {
        require(tokenSecundario.balanceOf(address(this)) >= _monto, "Saldo insuficiente");
        tokenSecundario.safeTransfer(_destino, _monto);
        emit TokensSecundariosRetirados(_monto, _destino);
    }
    
    function _retirarETH(uint256 _monto, address _destino) private nonReentrant {
        require(address(this).balance >= _monto, "Saldo ETH insuficiente");
        (bool success, ) = _destino.call{value: _monto}("");
        require(success, "Transferencia ETH fallida");
        emit ETHRetirado(_monto, _destino);
    }
    
    // ================== Funciones de Gestión de Propietarios ==================
    function _agregarPropietario(address _nuevoPropietario) internal {
        require(!esPropietario[_nuevoPropietario], "Ya es propietario");
        esPropietario[_nuevoPropietario] = true;
        propietarios.push(_nuevoPropietario);
    }
    
    function _removerPropietario(address _propietarioARemover, address _nuevoPropietario) internal {
        require(esPropietario[_propietarioARemover], "No es propietario");
        require(_nuevoPropietario != address(0), "Nuevo propietario invalido");
        require(!esPropietario[_nuevoPropietario], "Nuevo propietario ya existe");
        
        esPropietario[_propietarioARemover] = false;
        for (uint256 i = 0; i < propietarios.length; i++) {
            if (propietarios[i] == _propietarioARemover) {
                propietarios[i] = _nuevoPropietario;
                break;
            }
        }
        esPropietario[_nuevoPropietario] = true;
    }
    
    // ================== Funciones de Verificación ==================
    function verificarExpiracion(uint256 _idPropuesta) public {
        require(_idPropuesta < propuestas.length, "Propuesta no existe");
        Propuesta storage propuesta = propuestas[_idPropuesta];
        
        if (propuesta.estado == EstadoPropuesta.Activa && block.timestamp > propuesta.fechaExpiracion) {
            propuesta.estado = EstadoPropuesta.Expirada;
            emit PropuestaRechazada(_idPropuesta);
        }
    }

    function verificarExpiraciones() external {
        for (uint256 i = 0; i < propuestas.length; i++) {
            if (propuestas[i].estado == EstadoPropuesta.Activa && block.timestamp > propuestas[i].fechaExpiracion) {
                propuestas[i].estado = EstadoPropuesta.Expirada;
                emit PropuestaRechazada(i);
            }
        }
    }
    
    // ================== Funciones de Envío (sin cambios) ==================
    function enviarSecundarioa1(address destinatario, uint256 monto) external soloPropietario nonReentrant {
        require(tokenSecundario.balanceOf(address(this)) >= monto, "Saldo secundario insuficiente");
        tokenSecundario.safeTransfer(destinatario, monto);
        numeroOperacion++;
        emit OperacionRealizada(numeroOperacion);
    }
    
    function enviarPrimarioyETH(
        address[] calldata destinatariosPrimario,
        uint256[] calldata montosPrimario,
        address[] calldata destinatariosETH,
        uint256[] calldata montosETH
    ) external soloPropietario nonReentrant {
        require(destinatariosPrimario.length == montosPrimario.length, "Longitud de billeteras primario y montos no coinciden");
        require(destinatariosETH.length == montosETH.length, "Longitud de billeteras ETH y montos no coinciden");

        uint256 totalPrimario;
        for (uint256 i = 0; i < montosPrimario.length; i++) {
            totalPrimario += montosPrimario[i];
        }
        require(tokenPrimario.balanceOf(address(this)) >= totalPrimario, "Saldo primario insuficiente");

        uint256 totalETH;
        for (uint256 j = 0; j < montosETH.length; j++) {
            totalETH += montosETH[j];
        }
        require(address(this).balance >= totalETH, "Saldo ETH insuficiente");

        for (uint256 i = 0; i < destinatariosPrimario.length; i++) {
            tokenPrimario.safeTransfer(destinatariosPrimario[i], montosPrimario[i]);
        }
        
        for (uint256 j = 0; j < destinatariosETH.length; j++) {
            (bool success, ) = destinatariosETH[j].call{value: montosETH[j]}("");
            require(success, "Transferencia ETH fallida");
        }
        
        numeroOperacion++;
        emit OperacionRealizada(numeroOperacion);
    }
    
    // ================== Funciones de Consulta ==================
    function obtenerPropietarios() external view returns (address[] memory) {
        return propietarios;
    }
    
    function obtenerConteoDePropuestas() external view returns (uint256) {
        return propuestas.length;
    }
    
    function obtenerBalanceETH() external view returns (uint256) {
        return address(this).balance;
    }
    
    function obtenerDetallesPropuesta(uint256 _idPropuesta) external view returns (
        TipoPropuesta,
        address,
        address,
        address,
        uint256,
        uint256,
        EstadoPropuesta,
        uint256,
        uint256
    ) {
        require(_idPropuesta < propuestas.length, "Propuesta no existe");
        Propuesta storage p = propuestas[_idPropuesta];
        return (
            p.tipoPropuesta,
            p.proponente,
            p.direccionObjetivo,
            p.direccionAdicional,
            p.confirmaciones,
            p.rechazos,
            p.estado,
            p.fechaCreacion,
            p.fechaExpiracion
        );
    }
}