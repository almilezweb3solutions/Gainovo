/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXXXXXXNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNX0kdlc;,'.........',:coxOKNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0xl:'.                        .':oOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN0d:'.                                  .:d0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOl,.                                         .;xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMW0o'                                                ,OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMNO:.                                                 .oXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMNO;.                                                  .kWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMW0c.                         ..........                ;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMNd.                    .':ldk0KXXNNNNXKKOxoc,.        .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMK:                   .cx0NWMMMMMMMMMMMMMMMMMMWKkl'    .xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMWO,                 .:kXWMMMMMMMMMMMMMMMMMMMMMMMMMMNOc.;0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMWk.                .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMWO'                'kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMM0,                :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMXc                cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMWx.               ;KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMK;               .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMx.               cNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMNc               .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMK,               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOkXMMMMMMMMMMMMMMMM
MMMMMMMMMMMO.               '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0koc,.  :XMMMMMMMMMMMMMMM
MMMMMMMMMMM0'               .OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOxl;'.       .oWMMMMMMMMMMMMMM
MMMMMMMMMMMK,               .dWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKkoc,.              .kMMMMMMMMMMMMMM
MMMMMMMMMMMX:                :XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX0xl:'.                    ;KMMMMMMMMMMMMM
MMMMMMMMMMMWd                .xMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXkdc,.                           lNMMMMMMMMMMMM
MMMMMMMMMMMM0'                ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.                               .dWMMMMMMMMMMM
MMMMMMMMMMMMNl                 cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX:                                'OMMMMMMMMMMM
MMMMMMMMMMMMM0,                .lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0'                                :XMMMMMMMMMM
MMMMMMMMMMMMMWx.                .lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWx.          ...                   oNMMMMMMMMM
MMMMMMMMMMMMMMNo                  :KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNl     .,cokOo.                   .kWMMMMMMMM
MMMMMMMMMMMMMMMXc                  'xNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKl;ldOXWMMKl.                     ,0MMMMMMMM
MMMMMMMMMMMMMMMMXc                  .:OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWMMMMMNx'                        cXMMMMMMM
MMMMMMMMMMMMMMMMMXl                   .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXx,              .           .dWMMMMMM
MMMMMMMMMMMMMMMMMMNd.                    ,o0NMMMMMMMMMMMMMMMMMMMMMMMMMNOl'              .od.           .OMMMMMM
MMMMMMMMMMMMMMMMMMMWO,                     .,lx0NWMMMMMMMMMMMMMMMWNKxl'.               .dNNl          .;kWMMMMM
MMMMMMMMMMMMMMMMMMMMMXo.                       ..;coxkO000K00Oxdl;'.                  .kWMMK:   .':lx0XWMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMW0:.                               ...                         ;0WMMMM0ookKNWMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMWO:.                                                       .dNMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMNOc.                                                   .lKWMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.                                              'l0WMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0o;.                                        .:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc,.                                .'cxKWMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKkoc,..                    ..':okKNMMMMMMMMMMM   WWW.GAINOVO.COM    MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXKOxdlcc:;;;;;;::clodk0XNMMMMMMMMMMMMMMMM                      MMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
/////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/*//////////////////////////////////////////////////////////////
                         IERC165.sol
//////////////////////////////////////////////////////////////*/

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

/*//////////////////////////////////////////////////////////////
                         IERC20.sol
//////////////////////////////////////////////////////////////*/

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

/*//////////////////////////////////////////////////////////////
                     IERC20Metadata.sol
//////////////////////////////////////////////////////////////*/

interface IERC20Metadata {
    function decimals() external view returns (uint8);
}

/*//////////////////////////////////////////////////////////////
                        IERC1363.sol
//////////////////////////////////////////////////////////////*/

interface IERC1363 is IERC20, IERC165 {
    function transferAndCall(address to, uint256 value) external returns (bool);
    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);
    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);
    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);
    function approveAndCall(address spender, uint256 value) external returns (bool);
    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);
}

/*//////////////////////////////////////////////////////////////
                        SafeERC20.sol
//////////////////////////////////////////////////////////////*/

library SafeERC20 {
    error SafeERC20FailedOperation(address token);
    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
    }

    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {
        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));
    }

    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {
        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));
    }

    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
            _callOptionalReturn(token, approvalCall);
        }
    }

    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
        if (to.code.length == 0) {
            safeTransfer(token, to, value);
        } else if (!token.transferAndCall(to, value, data)) {
            revert SafeERC20FailedOperation(address(token));
        }
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        (bool success, bytes memory returndata) = address(token).call(data);
        if (!success || (returndata.length > 0 && !abi.decode(returndata, (bool)))) {
            revert SafeERC20FailedOperation(address(token));
        }
    }

    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        (bool success, bytes memory returndata) = address(token).call(data);
        return success && (returndata.length == 0 || abi.decode(returndata, (bool)));
    }
}

/*//////////////////////////////////////////////////////////////
                    Gainovo Dinamic Staking Contract
//////////////////////////////////////////////////////////////*/

contract StakingDinamicoGainovo {
    using SafeERC20 for IERC20;

    // Configuración de Multifirma
    address[] public propietarios;
    uint8 public constant MIN_PROPIETARIOS = 3;
    mapping(address => bool) public esPropietario;
    
    // Prevención de Reentrancia
    uint256 private constant _NO_ENTRADA = 1;
    uint256 private constant _ENTRADA = 2;
    uint256 private _estado;
    
    // Parámetros del Staking
    address private tokenStake;
    address private tokenRecompensa;
    uint256 private tiempoMinimo;
    uint256 private cantidadMinima;
    uint256 public tasaActual;
    
    // Histórico de Tasas
    struct TasaHistorica {
        uint256 timestamp;
        uint256 tasa;
    }
    TasaHistorica[] public historicoTasas;
    event TasaActualizada(uint256 tasa, uint256 timestamp);

    // Tipos de Propuestas Actualizados
    uint8 constant TIPO_AGREGAR_PROPIETARIO = 1;
    uint8 constant TIPO_ELIMINAR_PROPIETARIO = 2;
    uint8 constant TIPO_FINALIZAR_STAKE = 3;
    uint8 constant TIPO_RETIRAR_RECOMPENSAS = 4;
    uint8 constant TIPO_CAMBIAR_TOKEN_STAKE = 5;
    uint8 constant TIPO_CAMBIAR_TOKEN_RECOMPENSA = 6;
    uint8 constant TIPO_CAMBIAR_PLAZO_MINIMO = 7;
    uint8 constant TIPO_RETIRAR_STAKE_TOKENS = 8;
    
    // Estructuras de Datos
    struct Stake {
        uint256 inicio;
        uint256 cantidad;
        uint256 intereses;
        bool finalizado;
    }
    
    struct Propuesta {
        address creador;
        uint8 tipo;
        address direccionAfectada;
        uint256 valorNumerico;
        uint8 confirmaciones;
        uint40 timestamp;
        bool ejecutada;
        address destino;
    }
    
    mapping(address => Stake[]) private stakes;
    mapping(uint256 => Propuesta) public propuestas;
    mapping(uint256 => mapping(address => bool)) public confirmadoresPropuesta;
    mapping(address => mapping(uint256 => bool)) public nonces;
    mapping(address => mapping(uint256 => bool)) public noncesInicio;
    uint256 public contadorPropuestas;

    // Eventos Actualizados
    event PropietarioAgregado(address indexed nuevoPropietario);
    event PropietarioEliminado(address indexed propietarioEliminado);
    event StakeIniciado(address indexed usuario, uint256 cantidad, uint256 indice);
    event StakeFinalizado(address indexed usuario, address destino, uint256 cantidad, uint256 intereses, uint256 indice);
    event RecompensasDepositadas(uint256 cantidad);
    event RecompensasRetiradas(uint256 cantidad, address destino);
    event StakeTokensRetirados(uint256 cantidad, address destino);
    event PropuestaCreada(uint256 indexed id, address indexed creador, uint8 tipo, address direccionAfectada, uint256 valorNumerico);
    event PropuestaConfirmada(uint256 indexed id, address indexed votante);
    event PropuestaEjecutada(uint256 indexed id, address indexed ejecutor);
    event PropuestaCaducada(uint256 indexed id);
    event TokenStakeCambiado(address nuevoTokenStake);
    event TokenRecompensaCambiado(address nuevoTokenRecompensa);
    event PlazoMinimoCambiado(uint256 nuevoPlazo);

    modifier soloPropietario() {
        require(esPropietario[msg.sender], "Solo propietarios");
        _;
    }

    modifier noReentrante() {
        require(_estado != _ENTRADA, "Reentrancia detectada");
        _estado = _ENTRADA;
        _;
        _estado = _NO_ENTRADA;
    }

    constructor(
        address _tokenStake,
        address _tokenRecompensa,
        uint256 _tiempoMinimo,
        uint256 _cantidadMinima,
        address[] memory _propietarios
    ) {
        require(_propietarios.length >= MIN_PROPIETARIOS, "Minimo 3 propietarios");
        
        for(uint8 i = 0; i < _propietarios.length; i++) {
            address prop = _propietarios[i];
            require(prop != address(0), "Direccion invalida");
            require(!esPropietario[prop], "Propietario duplicado");
            esPropietario[prop] = true;
            propietarios.push(prop);
        }
        
        tokenStake = _tokenStake;
        tokenRecompensa = _tokenRecompensa;
        tiempoMinimo = _tiempoMinimo;
        cantidadMinima = _cantidadMinima;
        _estado = _NO_ENTRADA;
        
        // Inicialización de tasa dinámica
        tasaActual = calcularTasa();
        historicoTasas.push(TasaHistorica(block.timestamp, tasaActual));
        emit TasaActualizada(tasaActual, block.timestamp);
    }

    // Funciones de Usuario
    function iniciarStake(uint256 _cantidad) external noReentrante {
        require(_cantidad >= cantidadMinima, "Cantidad minima no alcanzada");
        IERC20(tokenStake).safeTransferFrom(msg.sender, address(this), _cantidad);
        
        stakes[msg.sender].push(Stake(
            block.timestamp,
            _cantidad,
            0,
            false
        ));
        
        actualizarTasa();
        emit StakeIniciado(msg.sender, _cantidad, stakes[msg.sender].length - 1);
    }

    function iniciarStakePorRelayer(
        address _user,
        uint256 _cantidad,
        uint256 _deadline,
        uint8 v_permit,
        bytes32 r_permit,
        bytes32 s_permit,
        uint256 _nonce,
        bytes memory _firmaStake
    ) external noReentrante {
        require(_cantidad >= cantidadMinima, "Cantidad minima no alcanzada");
        require(!noncesInicio[_user][_nonce], "Nonce ya usado");
        
        IERC20Permit(tokenStake).permit(
            _user,
            address(this),
            _cantidad,
            _deadline,
            v_permit,
            r_permit,
            s_permit
        );
        
        bytes32 messageHash = keccak256(abi.encodePacked(
            _user,
            address(this),
            _cantidad,
            _nonce,
            block.chainid
        ));
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));
        require(recoverSigner(ethSignedMessageHash, _firmaStake) == _user, "Firma invalida");
        
        noncesInicio[_user][_nonce] = true;
        IERC20(tokenStake).safeTransferFrom(_user, address(this), _cantidad);
        
        stakes[_user].push(Stake(
            block.timestamp,
            _cantidad,
            0,
            false
        ));
        
        actualizarTasa();
        emit StakeIniciado(_user, _cantidad, stakes[_user].length - 1);
    }

    function finalizarMiStake(uint256 _indice) external noReentrante {
        _finalizarStake(msg.sender, _indice, msg.sender);
    }

    function finalizarStakePorFirma(
        address _user,
        uint256 _indice,
        uint256 _nonce,
        bytes memory _signature
    ) external noReentrante {
        require(_indice < stakes[_user].length, "Indice invalido");
        require(!nonces[_user][_nonce], "Nonce ya usado");
        
        bytes32 messageHash = keccak256(abi.encodePacked(
            _user,
            address(this),
            _indice,
            _nonce,
            block.chainid
        ));
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));
        require(recoverSigner(ethSignedMessageHash, _signature) == _user, "Firma invalida");
        
        nonces[_user][_nonce] = true;
        _finalizarStake(_user, _indice, _user);
    }

    // Funciones de Tasa Dinámica CORREGIDAS
    function calcularTasa() public view returns (uint256) {
        uint256 totalStaked = IERC20(tokenStake).balanceOf(address(this));
        if (totalStaked == 0) return 0;
        
        uint256 balanceRecompensas = IERC20(tokenRecompensa).balanceOf(address(this));
        
        // Obtener decimales de ambos tokens
        uint8 decimalsStake = IERC20Metadata(tokenStake).decimals();
        uint8 decimalsReward = IERC20Metadata(tokenRecompensa).decimals();
        
        // Cálculo con ajuste de decimales
        uint256 tasa = (balanceRecompensas * 100 * (10**decimalsStake)) / 
                      (totalStaked * (10**decimalsReward));
        
        return tasa > 100 ? 100 : tasa;
    }

    function actualizarTasa() private {
        uint256 nuevaTasa = calcularTasa();
        if (nuevaTasa == tasaActual) return;
        
        tasaActual = nuevaTasa;
        historicoTasas.push(TasaHistorica(block.timestamp, nuevaTasa));
        emit TasaActualizada(nuevaTasa, block.timestamp);
    }

    // Funciones de Gestión de Recompensas
    function depositarRecompensas(uint256 _cantidad) external {
        IERC20(tokenRecompensa).safeTransferFrom(msg.sender, address(this), _cantidad);
        actualizarTasa();
        emit RecompensasDepositadas(_cantidad);
    }

    function _retirarRecompensas(uint256 _monto, address _destino) private {
        require(IERC20(tokenRecompensa).balanceOf(address(this)) >= _monto, "Saldo insuficiente");
        IERC20(tokenRecompensa).safeTransfer(_destino, _monto);
        actualizarTasa();
        emit RecompensasRetiradas(_monto, _destino);
    }

    function _retirarStakeTokens(uint256 _monto, address _destino) private {
        require(IERC20(tokenStake).balanceOf(address(this)) >= _monto, "Saldo insuficiente");
        IERC20(tokenStake).safeTransfer(_destino, _monto);
        emit StakeTokensRetirados(_monto, _destino);
    }

    // Funciones de Propuestas Actualizadas
    function votarPropuesta(uint256 _id) external soloPropietario {
        require(_id < contadorPropuestas, "Propuesta no existe");
        Propuesta storage p = propuestas[_id];
        require(!p.ejecutada, "Propuesta ya ejecutada");
        require(block.timestamp <= p.timestamp + 24 hours, "Propuesta caducada");
        require(!confirmadoresPropuesta[_id][msg.sender], "Ya has votado");
        
        confirmadoresPropuesta[_id][msg.sender] = true;
        p.confirmaciones += 1;
        emit PropuestaConfirmada(_id, msg.sender);
    }

    function ejecutarPropuesta(uint256 _id) external soloPropietario {
        require(_id < contadorPropuestas, "Propuesta no existe");
        Propuesta storage p = propuestas[_id];
        require(!p.ejecutada, "Propuesta ya ejecutada");
        require(block.timestamp <= p.timestamp + 24 hours, "Propuesta caducada");
        require(p.confirmaciones >= requiredConfirmations(), "No se ha alcanzado el umbral");
        
        p.ejecutada = true;
        _ejecutarPropuesta(_id);
        emit PropuestaEjecutada(_id, msg.sender);
    }

    function limpiarPropuesta(uint256 _id) external soloPropietario {
        require(_id < contadorPropuestas, "Propuesta no existe");
        Propuesta storage p = propuestas[_id];
        require(!p.ejecutada, "Propuesta ya ejecutada");
        require(block.timestamp > p.timestamp + 24 hours, "Propuesta aun en periodo");
        p.ejecutada = true;
        emit PropuestaCaducada(_id);
    }

    // Funciones de Creación de Propuestas Limpias
    function proponerCambiarTokenStake(address _nuevoToken) external soloPropietario {
        _crearPropuesta(TIPO_CAMBIAR_TOKEN_STAKE, _nuevoToken, 0, address(0));
    }

    function proponerCambiarTokenRecompensa(address _nuevoToken) external soloPropietario {
        _crearPropuesta(TIPO_CAMBIAR_TOKEN_RECOMPENSA, _nuevoToken, 0, address(0));
    }

    function proponerCambiarPlazoMinimo(uint256 _nuevoPlazo) external soloPropietario {
        require(_nuevoPlazo > 0, "Plazo invalido");
        _crearPropuesta(TIPO_CAMBIAR_PLAZO_MINIMO, address(0), _nuevoPlazo, address(0));
    }

    function proponerAgregarPropietario(address _nuevoPropietario) external soloPropietario {
        require(_nuevoPropietario != address(0), "Direccion invalida");
        require(!esPropietario[_nuevoPropietario], "Ya es propietario");
        _crearPropuesta(TIPO_AGREGAR_PROPIETARIO, _nuevoPropietario, 0, address(0));
    }

    function proponerEliminarPropietario(address _propietario) external soloPropietario {
        require(esPropietario[_propietario], "No es propietario");
        require(propietarios.length > MIN_PROPIETARIOS, "No se puede eliminar");
        _crearPropuesta(TIPO_ELIMINAR_PROPIETARIO, _propietario, 0, address(0));
    }

    function proponerFinalizarStakeSeguro(address _user, uint256 _indice, address _destino) external soloPropietario {
        require(_indice < stakes[_user].length, "Indice invalido");
        Stake memory s = stakes[_user][_indice];
        require(!s.finalizado, "Stake ya finalizado");
        _crearPropuesta(TIPO_FINALIZAR_STAKE, _user, _indice, _destino);
    }

    function proponerRetirarRecompensas(uint256 _monto, address _destino) external soloPropietario {
        require(_monto > 0, "Monto invalido");
        _crearPropuesta(TIPO_RETIRAR_RECOMPENSAS, _destino, _monto, address(0));
    }

    function proponerRetirarStakeTokens(uint256 _monto, address _destino) external soloPropietario {
        require(_monto > 0, "Monto invalido");
        _crearPropuesta(TIPO_RETIRAR_STAKE_TOKENS, _destino, _monto, address(0));
    }

    // Funciones Internas Optimizadas
    function _crearPropuesta(uint8 _tipo, address _direccion, uint256 _valor, address _destino) private {
        uint256 id = contadorPropuestas++;
        propuestas[id] = Propuesta(
            msg.sender,
            _tipo,
            _direccion,
            _valor,
            1,
            uint40(block.timestamp),
            false,
            _destino
        );
        confirmadoresPropuesta[id][msg.sender] = true;
        emit PropuestaCreada(id, msg.sender, _tipo, _direccion, _valor);
    }

    function _ejecutarPropuesta(uint256 _id) private {
        Propuesta storage p = propuestas[_id];
        
        if(p.tipo == TIPO_AGREGAR_PROPIETARIO) {
            _agregarPropietario(p.direccionAfectada);
        } else if(p.tipo == TIPO_ELIMINAR_PROPIETARIO) {
            _eliminarPropietario(p.direccionAfectada);
        } else if(p.tipo == TIPO_FINALIZAR_STAKE) {
            _finalizarStake(p.direccionAfectada, p.valorNumerico, p.destino);
        } else if(p.tipo == TIPO_RETIRAR_RECOMPENSAS) {
            _retirarRecompensas(p.valorNumerico, p.direccionAfectada);
        } else if(p.tipo == TIPO_RETIRAR_STAKE_TOKENS) {
            _retirarStakeTokens(p.valorNumerico, p.direccionAfectada);
        } else if(p.tipo == TIPO_CAMBIAR_TOKEN_STAKE) {
            tokenStake = p.direccionAfectada;
            emit TokenStakeCambiado(p.direccionAfectada);
        } else if(p.tipo == TIPO_CAMBIAR_TOKEN_RECOMPENSA) {
            tokenRecompensa = p.direccionAfectada;
            emit TokenRecompensaCambiado(p.direccionAfectada);
        } else if(p.tipo == TIPO_CAMBIAR_PLAZO_MINIMO) {
            tiempoMinimo = p.valorNumerico;
            emit PlazoMinimoCambiado(p.valorNumerico);
        }
    }

    function _finalizarStake(address _user, uint256 _indice, address _destino) private {
        Stake storage s = stakes[_user][_indice];
        require(!s.finalizado, "Stake ya finalizado");

        uint256 intereses = 0;
        if (block.timestamp - s.inicio >= tiempoMinimo) {
            intereses = calcularIntereses(_user, _indice);
        }

        s.finalizado = true;
        s.intereses = intereses;
        emit StakeFinalizado(_user, _destino, s.cantidad, intereses, _indice);

        IERC20(tokenStake).safeTransfer(_destino, s.cantidad);
        actualizarTasa();
        
        if (intereses > 0 && IERC20(tokenRecompensa).balanceOf(address(this)) >= intereses) {
            IERC20(tokenRecompensa).safeTransfer(_destino, intereses);
        }
    }

    function _agregarPropietario(address _nuevo) private {
        require(!esPropietario[_nuevo], "Ya es propietario");
        esPropietario[_nuevo] = true;
        propietarios.push(_nuevo);
        emit PropietarioAgregado(_nuevo);
    }

    function _eliminarPropietario(address _prop) private {
        require(esPropietario[_prop], "No es propietario");
        require(propietarios.length > MIN_PROPIETARIOS, "No se puede eliminar");
        esPropietario[_prop] = false;
        
        for(uint256 i = 0; i < propietarios.length; i++) {
            if(propietarios[i] == _prop) {
                if(i != propietarios.length - 1) {
                    propietarios[i] = propietarios[propietarios.length - 1];
                }
                propietarios.pop();
                break;
            }
        }
        emit PropietarioEliminado(_prop);
    }

    // Funciones de Consulta
    function obtenerStake(address _user, uint256 _indice) external view returns(Stake memory) {
        require(_indice < stakes[_user].length, "Indice invalido");
        return stakes[_user][_indice];
    }

    function calcularIntereses(address _user, uint256 _indice) public view returns(uint256) {
        require(_indice < stakes[_user].length, "Indice invalido");
        Stake memory s = stakes[_user][_indice];
        require(!s.finalizado, "Stake finalizado");
        uint256 tiempo = block.timestamp - s.inicio;
        
        // La tasa ya está calculada considerando los decimales
        // Solo necesitamos ajustar la base temporal
        return (s.cantidad * tasaActual * tiempo) / (100 * 365 days);
    }

    function requiredConfirmations() internal view returns (uint8) {
        return (uint8(propietarios.length) / 2) + 1;
    }

    function cantidadStakes(address _user) external view returns(uint256) {
        return stakes[_user].length;
    }

    // Funciones de Firmas
    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);
        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, "Invalid signature length");
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
    }
}

interface IERC20Permit {
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}